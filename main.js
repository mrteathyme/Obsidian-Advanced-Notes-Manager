/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// main.ts
var main_exports = {};
__export(main_exports, {
  default: () => DailyActivityTrackerPlugin
});
module.exports = __toCommonJS(main_exports);
var import_obsidian = require("obsidian");
var DailyActivityTrackerPlugin = class extends import_obsidian.Plugin {
  constructor() {
    super(...arguments);
    this.create_event_handler = async (created) => {
      if (created instanceof import_obsidian.TFile) {
        let today = new Date();
        let dateformatted = today.getFullYear() + "-" + String(today.getMonth() + 1).padStart(2, "0") + "-" + String(today.getDate()).padStart(2, "0");
        let folderPath = (0, import_obsidian.normalizePath)(`${dateformatted}`);
        if (created.extension !== "md") {
          folderPath = (0, import_obsidian.normalizePath)(folderPath + "/Attachments");
        }
        await sleep(50);
        if (this.app.vault.getAbstractFileByPath(folderPath) == null) {
          await this.app.vault.createFolder(folderPath);
          new import_obsidian.Notice(`created new daily folder: ${folderPath}`);
        }
        if (app.vault.getAbstractFileByPath((0, import_obsidian.normalizePath)(folderPath + "/" + created.basename + "." + created.extension)) !== null) {
          new import_obsidian.Notice(`Failed to move ${created.basename + created.extension} to ${folderPath} a note with that name already exists`);
          return;
        }
        if (folderPath + "/" + created.basename + "." + created.extension === created.path) {
          return;
        }
        await this.app.vault.rename(created, folderPath + "/" + created.basename + "." + created.extension);
        new import_obsidian.Notice(`Moved "${created.basename + "." + created.extension}" to ${folderPath}`);
      }
    };
    this.updateDailyNote = async (file) => {
      if (file !== null) {
        let today = new Date();
        let dateformatted = today.getFullYear() + "-" + String(today.getMonth() + 1).padStart(2, "0") + "-" + String(today.getDate()).padStart(2, "0");
        let dailyNoteName = `${dateformatted}.md`;
        let folderPath = `${dateformatted}`;
        let dailyNote = this.app.vault.getAbstractFileByPath((0, import_obsidian.normalizePath)(folderPath + "/" + dailyNoteName));
        if (dailyNote == null) {
          dailyNote = await this.app.vault.create(dailyNoteName, "---\nTags: [daily, organisation]\n---\n\n");
          new import_obsidian.Notice(`created daily note: ${dailyNoteName}`);
        }
        if (dailyNote instanceof import_obsidian.TFile) {
          let text = await this.app.vault.read(dailyNote);
          if (!text.contains(`[[${file.basename}]]`) && `${file.basename}.${file.extension}` !== dailyNoteName) {
            await this.app.vault.modify(dailyNote, text + `[[${file.basename}]]
`);
          }
        }
      }
    };
  }
  async onload() {
    this.app.workspace.onLayoutReady(() => {
      this.registerEvent(this.app.vault.on("create", this.create_event_handler));
      this.registerEvent(this.app.workspace.on("file-open", this.updateDailyNote));
    });
  }
  onunload() {
  }
};
//# sourceMappingURL=data:application/json;base64,ewogICJ2ZXJzaW9uIjogMywKICAic291cmNlcyI6IFsibWFpbi50cyJdLAogICJzb3VyY2VzQ29udGVudCI6IFsiLypcbkNvcHlyaWdodCAoYykgMjAyMiwgTXJ0ZWF0aHltZVxuQWxsIHJpZ2h0cyByZXNlcnZlZC5cblxuVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG5MSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4qL1xuXG5cbmltcG9ydCB7UGx1Z2luLCBURmlsZSwgTm90aWNlLCBUQWJzdHJhY3RGaWxlLCBub3JtYWxpemVQYXRofSBmcm9tICdvYnNpZGlhbidcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgRGFpbHlBY3Rpdml0eVRyYWNrZXJQbHVnaW4gZXh0ZW5kcyBQbHVnaW4ge1xuICAgIGFzeW5jIG9ubG9hZCgpIHtcbiAgICAgICAgdGhpcy5hcHAud29ya3NwYWNlLm9uTGF5b3V0UmVhZHkoKCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5yZWdpc3RlckV2ZW50KHRoaXMuYXBwLnZhdWx0Lm9uKCdjcmVhdGUnLHRoaXMuY3JlYXRlX2V2ZW50X2hhbmRsZXIpKTtcbiAgICAgICAgICAgIHRoaXMucmVnaXN0ZXJFdmVudCh0aGlzLmFwcC53b3Jrc3BhY2Uub24oJ2ZpbGUtb3BlbicsdGhpcy51cGRhdGVEYWlseU5vdGUpKTtcbiAgICAgICAgfSk7XG4gICAgfVxuXG5cdG9udW5sb2FkKCkge1xuXG5cdH1cblxuXG4gICAgcHJpdmF0ZSBjcmVhdGVfZXZlbnRfaGFuZGxlciA9IGFzeW5jIChjcmVhdGVkOiBUQWJzdHJhY3RGaWxlKSA9PiB7XG4gICAgICAgIGlmIChjcmVhdGVkIGluc3RhbmNlb2YgVEZpbGUpIHtcblxuICAgICAgICAgICAgbGV0IHRvZGF5ID0gbmV3IERhdGUoKTtcbiAgICAgICAgICAgIGxldCBkYXRlZm9ybWF0dGVkID0gdG9kYXkuZ2V0RnVsbFllYXIoKSArICctJyArIFN0cmluZyh0b2RheS5nZXRNb250aCgpICsgMSkucGFkU3RhcnQoMiwgJzAnKSArICctJyArIFN0cmluZyh0b2RheS5nZXREYXRlKCkpLnBhZFN0YXJ0KDIsICcwJyk7XG4gICAgICAgICAgICBsZXQgZm9sZGVyUGF0aCA9IG5vcm1hbGl6ZVBhdGgoYCR7ZGF0ZWZvcm1hdHRlZH1gKTtcbiAgICAgICAgICAgIGlmIChjcmVhdGVkLmV4dGVuc2lvbiAhPT0gJ21kJykge1xuICAgICAgICAgICAgICAgIGZvbGRlclBhdGggPSBub3JtYWxpemVQYXRoKGZvbGRlclBhdGggKyAnL0F0dGFjaG1lbnRzJyk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vVG9EbzogRmluZCBhIGJldHRlciB3YXkgdGhhbiBqdXN0IHNsZWVwaW5nLCBlLmcgcmV0cmlldmUgYSBwcm9taXNlIGZyb20gdGhlIHdvcmtzcGFjZSBmaWxlIG9wZW4gZXZlbnQgYW5kIGF3YWl0IGl0IG1heWJlP1xuICAgICAgICAgICAgYXdhaXQgc2xlZXAoNTApO1xuXG4gICAgICAgICAgICBpZiAodGhpcy5hcHAudmF1bHQuZ2V0QWJzdHJhY3RGaWxlQnlQYXRoKGZvbGRlclBhdGgpID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICBhd2FpdCB0aGlzLmFwcC52YXVsdC5jcmVhdGVGb2xkZXIoZm9sZGVyUGF0aCk7XG4gICAgICAgICAgICAgICAgbmV3IE5vdGljZShgY3JlYXRlZCBuZXcgZGFpbHkgZm9sZGVyOiAke2ZvbGRlclBhdGh9YCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoYXBwLnZhdWx0LmdldEFic3RyYWN0RmlsZUJ5UGF0aChub3JtYWxpemVQYXRoKGZvbGRlclBhdGggKyAnLycgKyBjcmVhdGVkLmJhc2VuYW1lICsgJy4nICsgY3JlYXRlZC5leHRlbnNpb24pKSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIG5ldyBOb3RpY2UoYEZhaWxlZCB0byBtb3ZlICR7Y3JlYXRlZC5iYXNlbmFtZSArIGNyZWF0ZWQuZXh0ZW5zaW9ufSB0byAke2ZvbGRlclBhdGh9IGEgbm90ZSB3aXRoIHRoYXQgbmFtZSBhbHJlYWR5IGV4aXN0c2ApO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChmb2xkZXJQYXRoICsgJy8nICsgY3JlYXRlZC5iYXNlbmFtZSAgKyAnLicgKyBjcmVhdGVkLmV4dGVuc2lvbiA9PT0gY3JlYXRlZC5wYXRoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYXdhaXQgdGhpcy5hcHAudmF1bHQucmVuYW1lKGNyZWF0ZWQsIGZvbGRlclBhdGggKyAnLycgKyBjcmVhdGVkLmJhc2VuYW1lICArICcuJyArIGNyZWF0ZWQuZXh0ZW5zaW9uKVxuICAgICAgICAgICAgLy90aGlzLnVwZGF0ZURhaWx5Tm90ZShjcmVhdGVkKTtcbiAgICAgICAgICAgIG5ldyBOb3RpY2UoYE1vdmVkIFwiJHtjcmVhdGVkLmJhc2VuYW1lICArICcuJyArIGNyZWF0ZWQuZXh0ZW5zaW9ufVwiIHRvICR7Zm9sZGVyUGF0aH1gKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHByaXZhdGUgdXBkYXRlRGFpbHlOb3RlID0gYXN5bmMgKGZpbGU6IFRGaWxlIHwgbnVsbCkgPT4ge1xuICAgICAgICBpZiAoZmlsZSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgbGV0IHRvZGF5ID0gbmV3IERhdGUoKTtcbiAgICAgICAgICAgIGxldCBkYXRlZm9ybWF0dGVkID0gdG9kYXkuZ2V0RnVsbFllYXIoKSArICctJyArIFN0cmluZyh0b2RheS5nZXRNb250aCgpICsgMSkucGFkU3RhcnQoMiwgJzAnKSArICctJyArIFN0cmluZyh0b2RheS5nZXREYXRlKCkpLnBhZFN0YXJ0KDIsICcwJyk7XG4gICAgICAgICAgICBsZXQgZGFpbHlOb3RlTmFtZSA9IGAke2RhdGVmb3JtYXR0ZWR9Lm1kYDtcbiAgICAgICAgICAgIGxldCBmb2xkZXJQYXRoID0gYCR7ZGF0ZWZvcm1hdHRlZH1gO1xuICAgICAgICAgICAgbGV0IGRhaWx5Tm90ZSA9IHRoaXMuYXBwLnZhdWx0LmdldEFic3RyYWN0RmlsZUJ5UGF0aChub3JtYWxpemVQYXRoKGZvbGRlclBhdGggKyAnLycgKyBkYWlseU5vdGVOYW1lKSk7XG4gICAgICAgICAgICBpZiAoZGFpbHlOb3RlID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAvL1RvRG86IEFkZCBUZW1wbGF0ZSBTZXR0aW5ncyBhbmQgVGFnIHNldHRpbmdzLCBqdXN0IGdvbm5hIGhhcmRjb2RlIHdpdGggdGhlIHRhZ3MgaSB1c2UgZm9yIG5vd1xuICAgICAgICAgICAgICAgIGRhaWx5Tm90ZSA9IGF3YWl0IHRoaXMuYXBwLnZhdWx0LmNyZWF0ZShkYWlseU5vdGVOYW1lLCBcIi0tLVxcblRhZ3M6IFtkYWlseSwgb3JnYW5pc2F0aW9uXVxcbi0tLVxcblxcblwiKTtcbiAgICAgICAgICAgICAgICBuZXcgTm90aWNlKGBjcmVhdGVkIGRhaWx5IG5vdGU6ICR7ZGFpbHlOb3RlTmFtZX1gKTsgICBcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChkYWlseU5vdGUgaW5zdGFuY2VvZiBURmlsZSkge1xuICAgICAgICAgICAgICAgIC8vVG9EbzogU2VjdGlvbiBGb3JtYXR0aW5nIGluc3RlYWQgb2YganVzdCBhcHBlbmRpbmdcbiAgICAgICAgICAgICAgICBsZXQgdGV4dCA9IGF3YWl0IHRoaXMuYXBwLnZhdWx0LnJlYWQoZGFpbHlOb3RlKTtcbiAgICAgICAgICAgICAgICBpZiAoIXRleHQuY29udGFpbnMoYFtbJHtmaWxlLmJhc2VuYW1lfV1dYCkgJiYgYCR7ZmlsZS5iYXNlbmFtZX0uJHtmaWxlLmV4dGVuc2lvbn1gICE9PSBkYWlseU5vdGVOYW1lKSB7XG4gICAgICAgICAgICAgICAgICAgIGF3YWl0IHRoaXMuYXBwLnZhdWx0Lm1vZGlmeShkYWlseU5vdGUsdGV4dCArIGBbWyR7ZmlsZS5iYXNlbmFtZX1dXVxcbmApXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxufVxuXG5cbi8qIFRvZG86IEFkZCBDb21tYW5kIHRvIHByb2Nlc3MgZXhpc3RpbmcgZmlsZXMgYW5kIGNyZWF0ZSBkYWlseSBmb2xkZXJzIGZvciBlYWNoIGFuZCBtb3ZlIHRoZW0gdGhlcmVcbkNhbiB1c2UgdGhlIGN0aW1lIHByb3BlcnR5IG9mIHRoZSBGaWxlU3RhdHMgVHlwZSB0aGF0IGlzIHJldHVybmVkIGZyb20gVEZpbGUuc3RhdCwgYXBpIGRvY3Mgc2F5IGl0cyBhIG51bWJlciBzbyBpbSBnb2luZyB0byBhc3N1bWUgaXRzIGluIHVuaXh0aW1lXG5cblNvIHNvbWV0aGluZyBsaWtlIGlmICh0aGlzLmFwcC52YXVsdC5nZXRBYnN0cmFjdEZpbGVCeVBhdGgoc29tZUZ1bmN0aW9uVGhhdENvbnZlcnRzVW5peFRvTG9jYWxUaW1lWm9uZShmaWxlLnN0YXQuY3RpbWUpKSA9PSBudWxsKSBjcmVhdGVGb2xkZXIgdGhlbiBkbyBtb3ZlIGV0YyBldGMqL1xuXG4vKiBUb2RvOiBBZGQgU2V0dGluZ3MgRnVuY3Rpb25hbGl0eSB0byBjb25maWd1cmUgZnVydGhlciBkeW5hbWljIGZvbGRlciBydWxlcyAobGlrZSBtb3ZpbmcgZmlsZXMgdG8gZm9sZGVycyBiYXNlZCBvbiBZQU1MIEZyb250bWF0dGVyLiBvciBkaXNhYmxpbmcgZGFpbHkgZnVuY3Rpb25hbGl0eSBldGMpKi9cbiJdLAogICJtYXBwaW5ncyI6ICI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFTQSxzQkFBa0U7QUFFbEUsSUFBcUIsNkJBQXJCLGNBQXdELHVCQUFPO0FBQUEsRUFBL0Q7QUFBQTtBQWFJLFNBQVEsdUJBQXVCLE9BQU8sWUFBMkI7QUFDN0QsVUFBSSxtQkFBbUIsdUJBQU87QUFFMUIsWUFBSSxRQUFRLElBQUksS0FBSztBQUNyQixZQUFJLGdC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
